package main

import (
	"bytes"
	"encoding/json"
	"flag"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"gopkg.in/yaml.v3"
)

const (
	schemaTypeObject     = "object"
	schemaTypeString     = "string"
	schemaTypeInteger    = "integer"
	schemaTypeNumber     = "number"
	schemaTypeBoolean    = "boolean"
	schemaTypeArray      = "array"
	schemaFormatDateTime = "date-time"
	outputDirPermission  = 0o750
	outputFilePermission = 0o600
)

type document struct {
	OpenAPI    string              `json:"openapi"`
	Info       info                `json:"info"`
	Servers    []server            `json:"servers"`
	Paths      map[string]pathItem `json:"paths"`
	Components components          `json:"components"`
}

type info struct {
	Title   string `json:"title"`
	Version string `json:"version"`
}

type server struct {
	URL string `json:"url"`
}

type components struct {
	Schemas map[string]*schema `json:"schemas"`
}

type schema struct {
	Ref        string             `json:"$ref"`
	Type       string             `json:"type"`
	Format     string             `json:"format"`
	Nullable   bool               `json:"nullable"`
	Properties map[string]*schema `json:"properties"`
	Items      *schema            `json:"items"`
	Required   []string           `json:"required"`
	Enum       []interface{}      `json:"enum"`
}

type pathItem struct {
	Get    *operation `json:"get"`
	Post   *operation `json:"post"`
	Put    *operation `json:"put"`
	Patch  *operation `json:"patch"`
	Delete *operation `json:"delete"`
}

type operation struct {
	OperationID string               `json:"operationId"`
	Summary     string               `json:"summary"`
	Description string               `json:"description"`
	Responses   map[string]*response `json:"responses"`
}

type response struct {
	Description string                `json:"description"`
	Content     map[string]*mediaType `json:"content"`
}

type mediaType struct {
	Schema *schema `json:"schema"`
}

type generator struct {
	doc             document
	imports         map[string]struct{}
	typeDefs        map[string]*schema
	emitted         map[string]bool
	typeDefinitions []string
	interfaceBuf    bytes.Buffer
}

func newGenerator(doc document) *generator {
	typeDefs := doc.Components.Schemas
	if typeDefs == nil {
		typeDefs = make(map[string]*schema)
	}
	return &generator{
		doc:      doc,
		imports:  make(map[string]struct{}),
		typeDefs: typeDefs,
		emitted:  make(map[string]bool),
	}
}

func main() {
	specPath := flag.String("spec", "", "path to openapi yaml file")
	outPath := flag.String("out", "", "output file path")
	pkg := flag.String("pkg", "openapi", "package name for generated code")
	flag.Parse()

	if *specPath == "" || *outPath == "" {
		fmt.Fprintln(os.Stderr, "spec and out must be provided")
		os.Exit(1)
	}

	content, err := os.ReadFile(*specPath)
	if err != nil {
		fatalf("read spec: %v", err)
	}

	var doc document
	if parseErr := json.Unmarshal(content, &doc); parseErr != nil {
		if yamlErr := yaml.Unmarshal(content, &doc); yamlErr != nil {
			fatalf("parse spec: %v", yamlErr)
		}
	}

	gen := newGenerator(doc)
	goCode, err := gen.generate(*pkg)
	if err != nil {
		fatalf("generate code: %v", err)
	}

	if err := os.MkdirAll(filepath.Dir(*outPath), outputDirPermission); err != nil {
		fatalf("create out dir: %v", err)
	}

	if err := os.WriteFile(*outPath, goCode, outputFilePermission); err != nil {
		fatalf("write output: %v", err)
	}
}

func fatalf(format string, args ...interface{}) {
	fmt.Fprintf(os.Stderr, format+"\n", args...)
	os.Exit(1)
}

func (g *generator) generate(pkg string) ([]byte, error) {
	g.generateTypes()
	g.generateInterface()

	var buf bytes.Buffer
	buf.WriteString("// Code generated by cmd/openapi; DO NOT EDIT.\n")
	buf.WriteString("\n")
	buf.WriteString("package ")
	buf.WriteString(pkg)
	buf.WriteString("\n\n")

	if len(g.imports) > 0 {
		buf.WriteString("import (\n")
		keys := make([]string, 0, len(g.imports))
		for key := range g.imports {
			keys = append(keys, key)
		}
		sort.Strings(keys)
		for _, pkgPath := range keys {
			buf.WriteString(fmt.Sprintf("\t\"%s\"\n", pkgPath))
		}
		buf.WriteString(")\n\n")
	}

	for _, def := range g.typeDefinitions {
		buf.WriteString(def)
		if !strings.HasSuffix(def, "\n\n") {
			buf.WriteString("\n")
		}
	}
	buf.Write(g.interfaceBuf.Bytes())

	raw := buf.Bytes()
	if os.Getenv("DEBUG_OPENAPI_GENERATOR") == "1" {
		fmt.Fprintln(os.Stderr, string(raw))
	}

	formatted, err := format.Source(raw)
	if err != nil {
		return nil, fmt.Errorf("format source: %w", err)
	}

	return formatted, nil
}

func (g *generator) generateTypes() {
	if len(g.typeDefs) == 0 {
		return
	}

	queue := make([]string, 0, len(g.typeDefs))
	for name := range g.typeDefs {
		queue = append(queue, name)
	}
	sort.Strings(queue)

	seen := make(map[string]struct{})
	for len(queue) > 0 {
		name := queue[0]
		queue = queue[1:]
		if g.emitted[name] {
			continue
		}
		s := g.typeDefs[name]
		if s == nil {
			continue
		}
		g.emitType(name, s)
		seen[name] = struct{}{}

		var additional []string
		for candidate, sch := range g.typeDefs {
			if sch == nil {
				continue
			}
			if g.emitted[candidate] {
				continue
			}
			if _, ok := seen[candidate]; ok {
				continue
			}
			alreadyQueued := false
			for _, q := range queue {
				if q == candidate {
					alreadyQueued = true
					break
				}
			}
			if !alreadyQueued {
				additional = append(additional, candidate)
			}
		}
		if len(additional) > 0 {
			sort.Strings(additional)
			queue = append(queue, additional...)
		}
	}
}

func (g *generator) emitType(name string, s *schema) {
	if g.emitted[name] || s == nil {
		return
	}
	g.emitted[name] = true

	switch {
	case s.Ref != "":
		refName := typeNameFromRef(s.Ref)
		if _, ok := g.typeDefs[refName]; !ok {
			g.typeDefs[refName] = nil
		}
		g.typeDefinitions = append(g.typeDefinitions, fmt.Sprintf("type %s %s\n\n", name, refName))
	case s.Type == schemaTypeObject:
		g.typeDefinitions = append(g.typeDefinitions, g.buildObjectType(name, s))
	case s.Type == schemaTypeString && len(s.Enum) > 0:
		g.typeDefinitions = append(g.typeDefinitions, fmt.Sprintf("type %s string\n\n", name))
	case s.Type == schemaTypeString:
		g.typeDefinitions = append(g.typeDefinitions, fmt.Sprintf("type %s string\n\n", name))
	case s.Type == schemaTypeInteger:
		g.typeDefinitions = append(g.typeDefinitions, fmt.Sprintf("type %s int\n\n", name))
	case s.Type == schemaTypeNumber:
		g.typeDefinitions = append(g.typeDefinitions, fmt.Sprintf("type %s float64\n\n", name))
	case s.Type == schemaTypeBoolean:
		g.typeDefinitions = append(g.typeDefinitions, fmt.Sprintf("type %s bool\n\n", name))
	case s.Type == schemaTypeArray && s.Items != nil:
		itemType := g.resolveType(name+"Item", s.Items)
		g.typeDefinitions = append(g.typeDefinitions, fmt.Sprintf("type %s []%s\n\n", name, itemType))
	default:
		g.typeDefinitions = append(g.typeDefinitions, fmt.Sprintf("type %s interface{}\n\n", name))
	}
}

func (g *generator) buildObjectType(name string, s *schema) string {
	g.ensureImportsForSchema(s)

	var b strings.Builder
	fmt.Fprintf(&b, "type %s struct {\n", name)

	required := make(map[string]struct{}, len(s.Required))
	for _, r := range s.Required {
		required[r] = struct{}{}
	}

	propNames := make([]string, 0, len(s.Properties))
	for prop := range s.Properties {
		propNames = append(propNames, prop)
	}
	sort.Strings(propNames)

	for _, prop := range propNames {
		propSchema := s.Properties[prop]
		fieldName := toCamel(prop)
		fieldType := g.resolveType(name+fieldName, propSchema)

		usePointer := propSchema.Nullable
		if _, ok := required[prop]; !ok {
			usePointer = true
		}

		if usePointer && !strings.HasPrefix(fieldType, "[]") && !strings.HasPrefix(fieldType, "map[") {
			fieldType = "*" + fieldType
		}

		fmt.Fprintf(&b, "\t%s %s `json:\"%s\"`\n", fieldName, fieldType, prop)
	}

	b.WriteString("}\n\n")
	return b.String()
}

func (g *generator) resolveType(parentName string, s *schema) string {
	if s == nil {
		return "interface{}"
	}

	if s.Ref != "" {
		refName := typeNameFromRef(s.Ref)
		if _, ok := g.typeDefs[refName]; !ok {
			g.typeDefs[refName] = nil
		}
		return refName
	}

	switch s.Type {
	case schemaTypeString:
		if s.Format == schemaFormatDateTime {
			g.imports["time"] = struct{}{}
			return "time.Time"
		}
		return "string"
	case schemaTypeInteger:
		return "int"
	case schemaTypeNumber:
		return "float64"
	case schemaTypeBoolean:
		return "bool"
	case schemaTypeArray:
		elemType := g.resolveType(parentName+"Item", s.Items)
		return "[]" + elemType
	case schemaTypeObject:
		if len(s.Properties) == 0 {
			return "map[string]interface{}"
		}
		inlineName := parentName
		if _, ok := g.typeDefs[inlineName]; !ok {
			g.typeDefs[inlineName] = s
		}
		return inlineName
	default:
		return "interface{}"
	}
}

func (g *generator) ensureImportsForSchema(s *schema) {
	if s == nil {
		return
	}
	stack := []*schema{s}
	for len(stack) > 0 {
		current := stack[len(stack)-1]
		stack = stack[:len(stack)-1]
		if current == nil {
			continue
		}
		if current.Format == "date-time" {
			g.imports["time"] = struct{}{}
		}
		if current.Items != nil {
			stack = append(stack, current.Items)
		}
		for _, prop := range current.Properties {
			stack = append(stack, prop)
		}
	}
}

func (g *generator) generateInterface() {
	// gather endpoints
	type endpoint struct {
		Method      string
		Path        string
		OperationID string
	}

	var endpoints []endpoint

	pathKeys := make([]string, 0, len(g.doc.Paths))
	for p := range g.doc.Paths {
		pathKeys = append(pathKeys, p)
	}
	sort.Strings(pathKeys)

	for _, path := range pathKeys {
		item := g.doc.Paths[path]
		if item.Get != nil {
			endpoints = append(endpoints, endpoint{Method: "GET", Path: path, OperationID: g.operationID("Get", path, item.Get)})
		}
		if item.Post != nil {
			endpoints = append(endpoints, endpoint{Method: "POST", Path: path, OperationID: g.operationID("Post", path, item.Post)})
		}
		if item.Put != nil {
			endpoints = append(endpoints, endpoint{Method: "PUT", Path: path, OperationID: g.operationID("Put", path, item.Put)})
		}
		if item.Patch != nil {
			endpoints = append(endpoints, endpoint{Method: "PATCH", Path: path, OperationID: g.operationID("Patch", path, item.Patch)})
		}
		if item.Delete != nil {
			endpoints = append(endpoints, endpoint{Method: "DELETE", Path: path, OperationID: g.operationID("Delete", path, item.Delete)})
		}
	}

	sort.SliceStable(endpoints, func(i, j int) bool {
		if endpoints[i].OperationID == endpoints[j].OperationID {
			if endpoints[i].Path == endpoints[j].Path {
				return endpoints[i].Method < endpoints[j].Method
			}
			return endpoints[i].Path < endpoints[j].Path
		}
		return endpoints[i].OperationID < endpoints[j].OperationID
	})

	if len(endpoints) == 0 {
		return
	}

	g.imports["github.com/labstack/echo/v4"] = struct{}{}

	g.interfaceBuf.WriteString("type ServerInterface interface {\n")
	seen := make(map[string]struct{})
	for _, ep := range endpoints {
		if _, ok := seen[ep.OperationID]; ok {
			continue
		}
		g.interfaceBuf.WriteString(fmt.Sprintf("\t%s(ctx echo.Context) error\n", ep.OperationID))
		seen[ep.OperationID] = struct{}{}
	}
	g.interfaceBuf.WriteString("}\n\n")

	g.interfaceBuf.WriteString("func RegisterHandlers(g *echo.Group, si ServerInterface) {\n")
	g.interfaceBuf.WriteString("\tif g == nil {\n")
	g.interfaceBuf.WriteString("\t\tpanic(\"nil echo group\")\n")
	g.interfaceBuf.WriteString("\t}\n")
	g.interfaceBuf.WriteString("\tif si == nil {\n")
	g.interfaceBuf.WriteString("\t\tpanic(\"nil server implementation\")\n")
	g.interfaceBuf.WriteString("\t}\n\n")
	for _, ep := range endpoints {
		echoMethod := strings.ToUpper(ep.Method)
		g.interfaceBuf.WriteString(fmt.Sprintf("\tg.%s(\"%s\", si.%s)\n", echoMethod, toEchoPath(ep.Path), ep.OperationID))
	}
	g.interfaceBuf.WriteString("}\n")
}

func (g *generator) operationID(prefix, path string, op *operation) string {
	if op.OperationID != "" {
		return toExported(op.OperationID)
	}
	joined := prefix + " " + path
	return toExported(joined)
}

func typeNameFromRef(ref string) string {
	if ref == "" {
		return ""
	}
	parts := strings.Split(ref, "/")
	return toExported(parts[len(parts)-1])
}

func toCamel(value string) string {
	return toExported(value)
}

func toExported(value string) string {
	delimiters := func(r rune) bool {
		return r == '_' || r == '-' || r == ' ' || r == '/' || r == ':'
	}
	parts := strings.FieldsFunc(value, delimiters)
	for i, part := range parts {
		if part == "" {
			continue
		}
		if part == strings.ToLower(part) {
			lower := strings.ToLower(part)
			parts[i] = strings.ToUpper(lower[:1]) + lower[1:]
			continue
		}
		parts[i] = strings.ToUpper(part[:1]) + part[1:]
	}
	result := strings.Join(parts, "")
	if result == "" {
		return "X"
	}
	return result
}

func toEchoPath(path string) string {
	path = strings.ReplaceAll(path, "{", ":")
	path = strings.ReplaceAll(path, "}", "")
	if path == "" {
		return "/"
	}
	return path
}
